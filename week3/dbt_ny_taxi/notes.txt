IMP Files:
1. dbt_project.yml
    - declare profile name
    - specify model structure and types
    - few more things regarding project

2. profiles.yml (in home dir):
    - Specify database credentials. Keep them seperate as dev and prd

3. schema.yml (inside model dir)
    - Specify sources from where data should be pulled

4. Macro
    - Similar to UDF functions like other programming languages.
    - Difference is UDF returns the result of computatitons, but macro in DBT returns the "code" itself.
    - Use to avoid repeatitive code and code readability.
    - Use exact same way config & source using jinja template.
    - While passing parameters in macro, always use '' quotes.

5. To run specific model use,
    - dbt run -m <model_name>
    - dbt run -m <model_name> <model_name>
    - dbt run --select <model_name>
    - dbt run --select +<model_name> (which would run all upstream dependencies of that model)
    - dbt build --select +<model_name> (along with seeds, tests, everything)

6. packages.yml
    - To use macro, models of different DBT project into our project, 
        we have to put those dependencies in packages.yml file.
    - To installed those dependencies run this command,
        
        dbt deps

    - It will download those packages in our project under dbt_packages(hidden).

7. Variables
    - Directly pass in sql file var() within jinja template
    - Also pass in dbt_project.yml file as global variables and use them inside sql Files
    - To run dbt model with variable in runtime
        dbt build --m <model.sql> --var 'is_test_run: false'

8. Seeds
    - Copy csv into csv dir
    - Run command 
        -> dbt seed 
    - If any updates in file, run refresh command
        -> dbt seed --full-refresh

    - We can define property for seed inside dbt_project.yml like column datatypes, etc.

    - dbt run will run all models except seeds, if you want to run seed as well, then run
        -> dbt build

    - Use ref() macro to refer seed inside models, use seed name to refer it.

9. Tests
    - Validate our model with respect to data quality, and logic
    - We can pass different test criteria (assumptions) in schema.yml under model section.
    - For each model, for individual columns we can put test constraints.
    - We can pass severity level if it fails in test like warn, error, etc.
    - These are some of tests values we can put,
        tests: 
          - unique: 
              severity: warn
          - not_null:
              severity: warn
          - relationships:
              to: ref('taxi_zone_lookup')
              field: locationid
              severity: warn
          - accepted_values:
              values: "{{ var('payment_type_values') }}"
              severity: warn
              quote: false
    - We can pass seed reference, variables while defining tests.

    - To run (all) tests, 
        -> dbt test

        